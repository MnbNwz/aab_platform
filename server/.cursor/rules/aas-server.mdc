---
description: AAS Platform Auto-Code Generation Rules

# AUTOMATIC CODE GENERATION RULES

## PROJECT CONTEXT
- **Platform**: AAS (All-American Services) - Contractor-Customer marketplace
- **Stack**: TypeScript, Node.js, Express, MongoDB, Stripe
- **Architecture**: RESTful API with role-based access control

## AUTO-GENERATION PATTERNS

### 1. MODEL CREATION
When creating new models, ALWAYS include:
```typescript
import { Schema, model, Types } from "mongoose";

// Standard schema pattern with timestamps
const Schema = new Schema({
  // Required fields first
  // Optional fields second  
  // Timestamps automatic
}, { timestamps: true });

// Add indexes for performance if needed
Schema.index({ field: 1 });
export const Model = model("ModelName", Schema);
```

### 2. CONTROLLER PATTERN
ALWAYS follow this controller structure:
```typescript
import { Response } from "express";
import { AuthenticatedRequest } from "@middlewares/types";

export const controllerName = async (req: AuthenticatedRequest, res: Response) => {
  try {
    // 1. Extract & validate params
    // 2. Check permissions
    // 3. Business logic
    // 4. Return success response
    res.json({ success: true, data: result });
  } catch (error) {
    console.error("Error in controllerName:", error);
    res.status(500).json({ success: false, message: "Internal server error" });
  }
};
```

### 3. ROUTE PATTERN
ALWAYS structure routes like this:
```typescript
import express from "express";
import { authenticate } from "@middlewares/auth";
import { requireRole } from "@middlewares/rbac";
import * as controller from "@controllers/controllerName";

const router = express.Router();
router.use(authenticate); // Auth required for all routes
router.get("/", controller.getItems);
router.post("/", requireRole(["admin"]), controller.createItem);
export default router;
```

### 4. SERVICE PATTERN
Business logic ALWAYS goes in services:
```typescript
import { Model } from "@models/model";
import { logErrorWithContext } from "@utils/logger";

export const serviceName = async (params: any) => {
  try {
    // Core business logic here
    return result;
  } catch (error) {
    logErrorWithContext(error as Error, { operation: "serviceName", params });
    throw error;
  }
};
```

## ROLE-BASED RULES

### CUSTOMER ENDPOINTS
- Can create/view own properties and job requests
- Can accept/reject bids on their jobs
- CANNOT access other users' data

### CONTRACTOR ENDPOINTS  
- Can view available leads (with membership limits)
- Can create bids on accessible jobs
- Can manage own profile and services
- CANNOT access customer contact info without lead purchase

### ADMIN ENDPOINTS
- Full system access with `/admin/` prefix
- User management with filtering/pagination
- System analytics and statistics
- ALWAYS require `requireAdmin` middleware

## AUTOMATIC FEATURES TO INCLUDE

### PAGINATION
For any list endpoint, ALWAYS add:
```typescript
const { page = 1, limit = 10 } = req.query;
const skip = (Number(page) - 1) * Number(limit);
// Include totalPages, totalItems in response
```

### FILTERING
For list endpoints, ALWAYS support common filters:
- `status`, `role`, `createdAt` ranges
- Search by `email`, `name` patterns
- Custom business logic filters

### ERROR HANDLING
ALWAYS include comprehensive error handling:
- Try-catch blocks in all async functions
- Contextual logging with operation names
- User-friendly error messages
- Proper HTTP status codes

### VALIDATION
ALWAYS validate inputs:
- Required fields checking
- Data type validation  
- Business rule validation
- Sanitization for security

## MEMBERSHIP & LEAD SYSTEM RULES

### LEAD ACCESS
When implementing lead features:
- Check membership tier and limits
- Respect timing delays (Basic: 24h, Standard: 12h, Premium: 0h)
- Record access in LeadAccess model
- Prevent duplicate charges
- Monthly limit tracking

### PAYMENT INTEGRATION
For payment endpoints:
- 3-phase job payments: deposit → pre-start → completion
- Stripe integration with webhook handling
- Proper error handling for payment failures
- Audit trail for all transactions

## FILE STRUCTURE AUTO-GENERATION

### NEW FEATURE IMPLEMENTATION
When implementing new features, create files in this order:
1. **Model**: `/models/featureName.ts`
2. **Service**: `/services/featureService.ts` 
3. **Controller**: `/controllers/featureController.ts`
4. **Routes**: `/routes/feature.ts`
5. **Types**: `/types/feature.ts` (if needed)
6. **Middleware**: `/middlewares/featureValidation.ts` (if needed)

### NAMING CONVENTIONS
- **Files**: camelCase (userController.ts)
- **Functions**: camelCase (getUserById)
- **Models**: PascalCase (User, JobRequest)
- **Constants**: UPPER_SNAKE_CASE (MEMBERSHIP_LIMITS)
- **Routes**: kebab-case (/job-request, /lead-access)

## SECURITY AUTO-RULES
ALWAYS implement:
- Authentication middleware on protected routes
- Role-based authorization where needed
- Input sanitization and validation
- Rate limiting for sensitive endpoints
- Proper error message sanitization (no internal details)

## PERFORMANCE AUTO-RULES
ALWAYS consider:
- Database indexes on frequently queried fields
- Pagination for large datasets
- Caching for expensive operations
- Efficient query patterns (avoid N+1 problems)
- Proper connection pooling

globs:
  - "**/*.ts"
  - "**/*.js"
alwaysApply: true
---
